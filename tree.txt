#
# Javascript Tree
# Written by Alexis Wilke for Made to Order Software Corp. (c) 2002-2017
#
# Copyright (c) 2002-2017 Made to Order Software Corp.
#
# Permission is hereby granted, free of charge, to any
# person obtaining a copy of this software and
# associated documentation files (the "Software"), to
# deal in the Software without restriction, including
# without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the
# following conditions:
#
# The above copyright notice and this permission notice
# shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
# ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
# LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
# EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

The following file documents the tree generated by the parser.
At the time, the tree is composed of nodes which can have children
and some data assigned to it. The data is composed of a type which
determines how the string, integer and floating point values can
be used. The following describes what you can find in the tree such
as the children and data of each possible node type.

Node are described with zero or more of the following fields:

	[when 'none', the node is marked standalone]
	String -- what the string represents (literal, identifier)
	Integer -- what the integer represents (literal, flags)
	Float -- what the float represents (literal)
	Child [#] -- what such and such child represents

The fields can be followed by [optional] meaning that it may not always
be present (WARNING: if an error occurs, non-optional child are likely
to be missing too.) Note that if the first child is optional but not the
second, you will need to test the first child type or the count to
know what is available in the list.



NODE_ATTRIBUTES
	Child * -- one of PUBLIC, PRIVATE, IDENTIFIER, TRUE, FALSE

	All directives can have attributes attached to them. See
	the Set/GetLink() with NodePtr::LINK_ATTRIBUTES.

NODE_BREAK
	String -- label of block to break (IDENTIFIER)

NODE_CASE
	Child 1 -- expression
	Child 2 -- expression [optional]

NODE_CATCH
	Child 1 -- the catch parameter (PARAMETERS) [optional]
	Child 2 -- the catch block of directives (DIRECTIVE_LIST)

NODE_CLASS
	String -- the name of the class
	Child 1* -- extends/implements (EXTENDS, IMPLEMENTS) [optional]
	Child 2 -- list of directives (DIRECTIVE_LIST) [optional]

NODE_CONTINUE
	String -- label of block to repeat right now

NODE_DIRECTIVE_LIST
	Child * -- directive (i.e. NODE_BREAK, expression, etc.) [optional]

NODE_DO
	Child 1 -- list of directives (DIRECTIVE_LIST)
	Child 2 -- continuation expression (the while expression)

NODE_EXTENDS
	Child 1 -- the expression representing the class to extend

NODE_FINALLY
	Child * -- list of directives (DIRECTIVE_LIST) [optional]

NODE_FOR
	Child 1 -- list of variables or first expression
	Child 2 -- in expression or 2nd expression which can be empty
	Child 3 -- 3rd expression which can be empty [optional]
	Child 4 -- list of directives (DIRECTIVE_LIST)

NODE_FUNCTION
	String -- name of the function
	Integer -- function flags (GETTER, SETTER)
	Child 1 -- list of parameters (PARAMETERS) [optional]
	Child 2 -- an expression representing the return type [optional]
	Child 3 -- list of directives (DIRECTIVE_LIST) [optional]

NODE_GOTO
	String -- label to jump to before to continue

NODE_IF
	Child 1 -- the condition expression
	Child 2 -- then: list of directives (DIRECTIVE_LIST)
	Child 3 -- else: list of directives (DIRECTIVE_LIST)

NODE_IMPORT
	String -- package name
	Child 1 -- rename to name (IDENTIFIER) [optional]

NODE_IMPLEMENTS
	Child 1 -- the expression representing the class to implement

NODE_NAMESPACE
	String -- name of the namespace starting here

NODE_PACKAGE
	String -- package name
	Integer -- package flags (INTRINSIC)
	Child 1 -- list of directives (DIRECTIVE_LIST)

NODE_PARAM
	String -- parameter name (IDENTIFIER)
	Integer -- parameter flags (IN, OUT, CONST, REST, NAMED, UNCHECKED)
	Child 1 -- expression parameter type [optional]
	Child 2 -- initializer (SET) [optional]

NODE_PARAMETERS
	Child * -- a list of parameters (PARAM, REST)

NODE_PROGRAM
	Child * -- package declaration (PACKAGE) [optional]
	Child * -- list of directives (DIRECTIVE_LIST) [optional]

NODE_RETURN
	Child 1 -- expression to return [optional]

NODE_ROOT (user defined only to record multiple modules)
	Child * -- a list of programs (PROGRAM)

NODE_SET
	Child 1 - expression

NODE_SWITCH
	Child 1 -- expression
	Child 2 -- list of directives (DIRECTIVE_LIST)

NODE_TRY
	Child * -- list of directives (DIRECTIVE_LIST) [optional]

NODE_USE
	Child 1 -- expression representing the namespace to use

NODE_VAR
	Child * -- list of variables (VARIABLE)

NODE_VARIABLE
	String -- name of the variable (IDENTIFIER)
	Integer -- variable flags (CONST)
	Child 1 -- expression representing the type [optional]
	Child 2 -- initializer sub-expression (SET) [optional]

NODE_WHILE
	Child 1 -- conditional expression
	Child 2 -- list of directives (DIRECTIVE_LIST)

NODE_WITH
	Child 1 -- conditional expression
	Child 2 -- list of directives (DIRECTIVE_LIST)

